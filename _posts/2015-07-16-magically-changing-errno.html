---
title: The Magically Changing Errno
layout: post
excerpt: Poof!
---

<div class="row">
<div class="large-12 columns">
	<h1>
		The Magically Changing <code>errno</code>
	</h1>
<hr>
</div>
</div>
<div class="row">
<div class="large-12 columns">

	<p>A while ago, I wrote a <a href="http://dbittman.github.io/2014/11/05/fighting-with-your-compiler.html">post</a> complaining about GCC changing my memset function into a recursive call to itself.
	I found that very funny. So, I messed around with this stuff a bit, and found something even funnier.</p>

	<p>
	If you have a simple loop to zero a set of values, you may think that it's essentially equivalent to a call to memset. But it isn't.
	GCC will commonly convert such a loop into a memset call for various optimization reasons. But they're both just
	zeroing memory, so what's the problem?
	Say you call some library function and you have a value in errno that you care about. You then loop over an array,
	zeroing each element. You wouldn't have expected the value of errno to change over the course of that loop - after
	all, you never mention it directly...
	</p>
	<p>
	...but can it change anyway? This optimization into a call to memset could pose a problem, because as it turns out,
	a small detail in the C99 standard allows the C library to change the value of errno during a call to memset/memcpy/etc.
	I wrote a small proof-of-concept that shows how errno could change without a program mentioning it directly nor calling
	any library functions that would change it.
	</p>
	
	<p>Proof! Because that's important. Here is a replacement memset function which can be compiled into a shared library.</p>
	<pre class="brush: cpp">
    	void *memset(void *s, int c, size_t n)
        {
        	fprintf(stderr, "replacement memset called\n");
            unsigned char *ptr = s;
            while(n--) {
        		*(ptr++) = (unsigned char)c;
            }
            errno = 99;
            return s;
        }

	</pre>
	<p>aaaaand here is a simple program that demonstrates the issue.</p>
	<pre class="brush: cpp">
	  	void manipulate_array(char *buffer, char c, int n)
	  	{
	  		errno = 0;
	  		fprintf(stderr, "errno value: %d\n", errno);
	  	    while(n--) {
	  			*buffer++ = c;
	  			// other code here maybe
	  		}
	  	    fprintf(stderr, "new value of errno: %d\n", errno);
	  	}
	  	int main(int argc, char **argv)
	  	{
	  	    char buffer[1024];
	  		manipulate_array(buffer, 0, 1024);
	  	    return 0;
	  	}
	</pre>
	<p>Put together:
	<blockquote>
		# LD_PRELOAD=./memset_errno.so ./test<br>
        errno value: 0<br>
        replacement memset called<br>
        new value of errno: 99
    </blockquote>
    Ha. Funny how that goes, cheeky little errno changing itself around without me even touching it! Yeah, yeah, I know, I change it in my
    memset replacement. But that's not me! That's totally the standard library!
    </p>

    <h3>Practicality?</h3>
    <p>
    So, turns out none of the C libraries I looked at (glibc, newlib, dietlibc, etc) do this. I mean, why would they - changing errno inside
    memset is completely insane. What's memset gonna do, fail? The only real error condition would result in a segfault anyway. So, whatever, right?
    </p>

    <p>
    It's not like gcc claims full compliance with the standard anyway. Furthermore, a <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56888">bug
    	report</a> was filed where they discussed some of the implications of this. Gcc emits calls to memcpy and friends to deal with structs anyway,
    so if a C library decides to mess with errno, it's totally possible for code to break.</p>

    <p>Again, this isn't considered a bug. This one, which stems from the same issue that caused my memset function to become recursive, has a worse
    side effect in a way - silent changes to a variable. In practice, it doesn't matter, because in practice, this doesn't ever happen. But we should
    not have to settle for that unsatisfying answer.</p>


</div>
</div>

<div class="row">
	<div class="small-12 columns">
		<p><em>posted 2014-11-05 by Daniel Bittman (<a href="mailto:danielbittman1@gmail.com">send me an email</a> or <a href="http://twitter.com/danielbittman">follow me on twitter</a>!)</em></p>
	</div>
</div>

